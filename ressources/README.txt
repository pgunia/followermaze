Follower Maze Server README

Architecture / Implementation
Connection / Socket Handling
The Follower Maze Server is a message dispatcher that receives messages from an event source, processes and forwards them to clients that are connected to the server. Event sources connect on port 9090, clients on port 9099. The classes that deal with those connections are subclasses of BaseDispatcher and implement the basic logic which is necessary to listen for incoming connections on a specific port. Both classes use Java NIO sockets. As soon as an event source or a client connects on the specified ports, the server sockets accept this connection and create a socket channel which is used for further communication. To decouple this listening logic from the processing of the channels itself, the implementation uses executor services. For every accepted connection, a new instance of one of the two subclasses of ConnectionHandler is created that both implement the Runnable interface and thus can be added to an executor which runs them with a number of pooled threads. UserClientConnectionHandler is used to communicate with clients that connect on port 9099 while EventConnectionHandler handles connections established to the event source port 9090. While the executor thread pool for UserClientConnectionsHandler instances uses 100 threads as a default value and thus processes up to 100 parallel incoming requests concurrently, the exexcutor inside the EventDispatcher only uses one single thread. This is due to the fact that the specification of the follower-maze only uses one single event source that connects to the server at any given point in time. Thus the implementation uses a single thread executor within the event dispatcher to reduce the overall ressource consumption. EventConnectionHandler and UserClientConnectionHandler share the same logic to read data from the socket channel implemented in the readMessage() method inherited from the ConnectionHandler. Both classes allocate ByteBuffers of a given maximum buffer size. These buffers are used to read data from the socket. These buffers are then copied to a second buffer of smaller size on a per-byte-basis to check for the message terminator inside the byte stream. As soon as the terminator has been reached, the ByteBuffer is passed to a subclass specific implementation of the processMessage() method, triggering different processing steps. 

Message specific processing
There are two types of messages that need to be handled by the server. Events are sent from the event source, they need to be parsed, processed and depending on their type, might be forwarded to connected clients. User client messages are sent when a client connects to the server on port 9099. The message it sends contains its ID. Those messages trigger a registration process inside the UserRegistryService. The message is parsed to extract the client ID and to construct a new Client instance. This client instance contains the ID and the socket channel over which the communication with the client is established. The main service for further user handling is the UserRegistryService. This service is implemented via the enum singleton pattern and offers several methods for user registration and removal and the handling of followed / follower relationships in the system. On registration, the client instance is added to a ConcurrentHashMap that uses the client ID as a key and maps it to the client instance as a value for fast access during further processing. 
Handling event messages is managed in a comparable way. The EventConnectionHandler processes event messages by extracting and conerting them into a String representation. The extracted payload of the message is passed to an EventFactory that parses their content and constructs one of the five implementations of the Event interface. Those subclasses (BroadcastEvent, FollowEvent, UnfollowEvent, PrivateMsgEvent, StatusUpdateEvent) represent the different event types that the server needs to handle. Each of the the classes implements a processEvent() method which is used to realize event specific processing steps. If the extracted message doesn´t describe a valid event, an exception is written to the logs and no event is created, though the regular processing is not disturbed by such errors. After creating an event instance via the EventFactory, the event is passed to the EventHandlerService. As the UserRegistryService, this service is implemented using the enum singleton pattern. The main method of this service is addEvent(). It gets the beforehand created event instance and pushes it onto a priority queue which sorts the events added based on their sequence number. Thus a call to its peek() method returns the event with the currently smallest sequence number. After adding the event, an EventWorker is created and started. The EventWorker fulfills the same steps inside a loop. It first takes the first element in the priority queue and compares its sequence number to the sequence number of the next event to be processed. If the those numbers match, it calls the processEvent() method of the event. After the event has been processed, the sequence number is incremented and the loop starts again until the next sequence number doesn´t match the sequence number of the first event on the queue which means that the next event has not been sent yet. In an earlier version, the EventWorker instances were added to an executor which decouples the event creation from its processing. The problem with that approach compared to the current implementation is the fact, that it allows the EventDispatcher to flood the EventQueue and add more and more EventWorker instances to the executor. Due to the fact that the event processing needs to be sequential at that point to guarantee that the events are processed in the order given by their sequence number, this part of the processing can not be done with more than one thread. Performing the event processing inside the same thread balances the load, because no more events can be added and processed until the EventWorker has completed its job. 

Event processing
As mentioned before, the different types of events need to be processed in an event specific way. In general, the processing can be divided into two major parts. Depending on the event type, changes to the user registry need to be performed (FollowEvent, UnfollowEvent). Additionally all events besides UnfollowEvent require to send notifications to connected clients. Thus one step is to retrieve all clients from the user registry that have to be notified of the event processing. This might be all connected clients (BroadcastEvent) or all clients that are currently following a specific client (StatusUpdateEvent) or simply to forward messsages to a specific client (FollowEvent, PrivateMsgEvent). The notification itself uses the socket channels stored inside the Client instances and sends the payload over this socket. The notification itself can be decoupled from the retrieval of clients to be notified to increase concurrency and throughput. Still it has to guarantee that all notifications that are sent to a client arrive in the correct order. To achieve this while using as many parallel threads as possible, the UserRegistryService holds an single thread executor for every client that´s connected to the server. A notification is implemented by adding a ClientNotification instance to the client´s job queue. This approach guarantees that the messages arrive in the correct order due to sequential processing with one single thread per client, notifications for different client can be processed in parallel. I´ve tried to further decouple the event processing by analyzing the incoming events and processing them in parallel if possible, though the overhead caused by this approach doesn´t come with any performance benefits. This is due to the fact that the events, that might be processed in parallel are the ones that can be processed very fast (FollowEvent, ProcessEvent, PrivateMsgEvent), because they only require simple calls to the UserRegistryService whereas the remaining events need to loop over lists of clients. If the processing of the first mentioned events would be more time consuming, the approach might help to increase the throughput, nevertheless this approach has been discarded in favor of more simplicity.
