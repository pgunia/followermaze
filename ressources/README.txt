Follower Maze Server README

Architecture / Implementation
Connection / Socket Handling
The Follower Maze Server is a message dispatcher that receives messages from an event source, processes and forwards them to clients that are connected to the server. Event sources connect on port 9090, clients on port 9099. The classes that deal with those connections are subclasses of BaseDispatcher and implement the basic logic which is necessary to listen for incoming connections on a specific port. Both classes use Java NIO sockets. As soon as an event source or a client connects on the specified ports, the server sockets accept this connection and create a socket channel which is used for further communication. To decouple this listening logic from the processing of the channels itself, the implementation uses executor services. For every accepted connection, a new instance of one of the two subclasses of ConnectionHandler is created that both implement the Runnable interface and thus can be added to an executor which runs them with a number of pooled threads. UserClientConnectionHandler is used to communicate with clients that connect on port 9099 while EventConnectionHandler handles connections established to the event source port 9090. While the executor thread pool for UserClientConnectionsHandler instances uses 100 threads as a default value and thus processes up to 100 parallel incoming requests concurrently, the exexcutor inside the EventDispatcher only uses one single thread. This is due to the fact that the specification of the follower-maze only uses one single event source that connects to the server at any given point in time. Thus the implementation uses a single thread executor within the event dispatcher to reduce the overall ressource consumption. EventConnectionHandler and UserClientConnectionHandler share the same logic to read data from the socket channel implemented in the readMessage() method inherited from the ConnectionHandler. Both classes allocate ByteBuffers of a given maximum buffer size. These buffers are used to read data from the socket. These buffers are then copied to a second buffer of smaller size on a per-byte-basis to check for the message terminator inside the byte stream. As soon as the terminator has been reached, the ByteBuffer is passed to a subclass specific implementation of the processMessage() method, triggering different processing steps. 

Message specific processing
There are two types of messages that need to be handled by the server. Events are sent from the event source, they need to be parsed, processed and depending on their type, might be forwarded to connected clients. User client messages are sent when a client connects to the server on port 9099. The message it sends contains its ID. Those messages trigger a registration process inside the UserRegistryService. The message is parsed to extract the client ID and to construct a new Client instance. This client instance contains the ID and the socket channel over which the communication with the client is established. The main service for further user handling is the UserRegistryService. This service is implemented via the enum singleton pattern and offers several methods for user registration and removal and the handling of followed / follower relationships in the system. On registration, the client instance is added to a ConcurrentHashMap that uses the client ID as a key and maps it to the client instance as a value for fast access during further processing. 
Handling event messages is managed in a comparable way. The EventConnectionHandler processes event messages by extracting and conerting them into a String representation. The extracted payload of the message is passed to an EventFactory that parses their content and constructs one of the five implementations of the Event interface. Those subclasses (BroadcastEvent, FollowEvent, UnfollowEvent, PrivateMsgEvent, StatusUpdateEvent) represent the different event types that the server needs to handle. Each of the the classes implements a processEvent() method which is used to realize event specific processing steps. If the extracted message doesnÂ´t describe a valid event, an exception is written to the logs and no event is created, though the regular processing is not disturbed by such errors. After creating an event instance via the EventFactory, the event is passed to the EventHandlerService. As the UserRegistryService, this service is implemented using the enum singleton pattern. The main method of this service is addEvent(). ADD EVENT